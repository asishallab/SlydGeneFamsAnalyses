(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);throw new Error("Cannot find module '"+o+"'")}var f=n[o]={exports:{}};t[o][0].call(f.exports,function(e){var n=t[o][1][e];return s(n?n:e)},f,f.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
if (typeof biojs === 'undefined') {
  module.exports = biojs = {}
}
if (typeof biojs.vis === 'undefined') {
  module.exports = biojs.vis = {}
}
biojs.vis.easy_features = require('./index')

},{"./index":2}],2:[function(require,module,exports){
module.exports = require("./src/index");

},{"./src/index":6}],3:[function(require,module,exports){
/**
 * Standalone extraction of Backbone.Events, no external dependency required.
 * Degrades nicely when Backone/underscore are already available in the current
 * global context.
 *
 * Note that docs suggest to use underscore's `_.extend()` method to add Events
 * support to some given object. A `mixin()` method has been added to the Events
 * prototype to avoid using underscore for that sole purpose:
 *
 *     var myEventEmitter = BackboneEvents.mixin({});
 *
 * Or for a function constructor:
 *
 *     function MyConstructor(){}
 *     MyConstructor.prototype.foo = function(){}
 *     BackboneEvents.mixin(MyConstructor.prototype);
 *
 * (c) 2009-2013 Jeremy Ashkenas, DocumentCloud Inc.
 * (c) 2013 Nicolas Perriault
 */
/* global exports:true, define, module */
(function() {
  var root = this,
      nativeForEach = Array.prototype.forEach,
      hasOwnProperty = Object.prototype.hasOwnProperty,
      slice = Array.prototype.slice,
      idCounter = 0;

  // Returns a partial implementation matching the minimal API subset required
  // by Backbone.Events
  function miniscore() {
    return {
      keys: Object.keys || function (obj) {
        if (typeof obj !== "object" && typeof obj !== "function" || obj === null) {
          throw new TypeError("keys() called on a non-object");
        }
        var key, keys = [];
        for (key in obj) {
          if (obj.hasOwnProperty(key)) {
            keys[keys.length] = key;
          }
        }
        return keys;
      },

      uniqueId: function(prefix) {
        var id = ++idCounter + '';
        return prefix ? prefix + id : id;
      },

      has: function(obj, key) {
        return hasOwnProperty.call(obj, key);
      },

      each: function(obj, iterator, context) {
        if (obj == null) return;
        if (nativeForEach && obj.forEach === nativeForEach) {
          obj.forEach(iterator, context);
        } else if (obj.length === +obj.length) {
          for (var i = 0, l = obj.length; i < l; i++) {
            iterator.call(context, obj[i], i, obj);
          }
        } else {
          for (var key in obj) {
            if (this.has(obj, key)) {
              iterator.call(context, obj[key], key, obj);
            }
          }
        }
      },

      once: function(func) {
        var ran = false, memo;
        return function() {
          if (ran) return memo;
          ran = true;
          memo = func.apply(this, arguments);
          func = null;
          return memo;
        };
      }
    };
  }

  var _ = miniscore(), Events;

  // Backbone.Events
  // ---------------

  // A module that can be mixed in to *any object* in order to provide it with
  // custom events. You may bind with `on` or remove with `off` callback
  // functions to an event; `trigger`-ing an event fires all callbacks in
  // succession.
  //
  //     var object = {};
  //     _.extend(object, Backbone.Events);
  //     object.on('expand', function(){ alert('expanded'); });
  //     object.trigger('expand');
  //
  Events = {

    // Bind an event to a `callback` function. Passing `"all"` will bind
    // the callback to all events fired.
    on: function(name, callback, context) {
      if (!eventsApi(this, 'on', name, [callback, context]) || !callback) return this;
      this._events || (this._events = {});
      var events = this._events[name] || (this._events[name] = []);
      events.push({callback: callback, context: context, ctx: context || this});
      return this;
    },

    // Bind an event to only be triggered a single time. After the first time
    // the callback is invoked, it will be removed.
    once: function(name, callback, context) {
      if (!eventsApi(this, 'once', name, [callback, context]) || !callback) return this;
      var self = this;
      var once = _.once(function() {
        self.off(name, once);
        callback.apply(this, arguments);
      });
      once._callback = callback;
      return this.on(name, once, context);
    },

    // Remove one or many callbacks. If `context` is null, removes all
    // callbacks with that function. If `callback` is null, removes all
    // callbacks for the event. If `name` is null, removes all bound
    // callbacks for all events.
    off: function(name, callback, context) {
      var retain, ev, events, names, i, l, j, k;
      if (!this._events || !eventsApi(this, 'off', name, [callback, context])) return this;
      if (!name && !callback && !context) {
        this._events = {};
        return this;
      }

      names = name ? [name] : _.keys(this._events);
      for (i = 0, l = names.length; i < l; i++) {
        name = names[i];
        if (events = this._events[name]) {
          this._events[name] = retain = [];
          if (callback || context) {
            for (j = 0, k = events.length; j < k; j++) {
              ev = events[j];
              if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                  (context && context !== ev.context)) {
                retain.push(ev);
              }
            }
          }
          if (!retain.length) delete this._events[name];
        }
      }

      return this;
    },

    // Trigger one or many events, firing all bound callbacks. Callbacks are
    // passed the same arguments as `trigger` is, apart from the event name
    // (unless you're listening on `"all"`, which will cause your callback to
    // receive the true name of the event as the first argument).
    trigger: function(name) {
      if (!this._events) return this;
      var args = slice.call(arguments, 1);
      if (!eventsApi(this, 'trigger', name, args)) return this;
      var events = this._events[name];
      var allEvents = this._events.all;
      if (events) triggerEvents(events, args);
      if (allEvents) triggerEvents(allEvents, arguments);
      return this;
    },

    // Tell this object to stop listening to either specific events ... or
    // to every object it's currently listening to.
    stopListening: function(obj, name, callback) {
      var listeners = this._listeners;
      if (!listeners) return this;
      var deleteListener = !name && !callback;
      if (typeof name === 'object') callback = this;
      if (obj) (listeners = {})[obj._listenerId] = obj;
      for (var id in listeners) {
        listeners[id].off(name, callback, this);
        if (deleteListener) delete this._listeners[id];
      }
      return this;
    }

  };

  // Regular expression used to split event strings.
  var eventSplitter = /\s+/;

  // Implement fancy features of the Events API such as multiple event
  // names `"change blur"` and jQuery-style event maps `{change: action}`
  // in terms of the existing API.
  var eventsApi = function(obj, action, name, rest) {
    if (!name) return true;

    // Handle event maps.
    if (typeof name === 'object') {
      for (var key in name) {
        obj[action].apply(obj, [key, name[key]].concat(rest));
      }
      return false;
    }

    // Handle space separated event names.
    if (eventSplitter.test(name)) {
      var names = name.split(eventSplitter);
      for (var i = 0, l = names.length; i < l; i++) {
        obj[action].apply(obj, [names[i]].concat(rest));
      }
      return false;
    }

    return true;
  };

  // A difficult-to-believe, but optimized internal dispatch function for
  // triggering events. Tries to keep the usual cases speedy (most internal
  // Backbone events have 3 arguments).
  var triggerEvents = function(events, args) {
    var ev, i = -1, l = events.length, a1 = args[0], a2 = args[1], a3 = args[2];
    switch (args.length) {
      case 0: while (++i < l) (ev = events[i]).callback.call(ev.ctx); return;
      case 1: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1); return;
      case 2: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2); return;
      case 3: while (++i < l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); return;
      default: while (++i < l) (ev = events[i]).callback.apply(ev.ctx, args);
    }
  };

  var listenMethods = {listenTo: 'on', listenToOnce: 'once'};

  // Inversion-of-control versions of `on` and `once`. Tell *this* object to
  // listen to an event in another object ... keeping track of what it's
  // listening to.
  _.each(listenMethods, function(implementation, method) {
    Events[method] = function(obj, name, callback) {
      var listeners = this._listeners || (this._listeners = {});
      var id = obj._listenerId || (obj._listenerId = _.uniqueId('l'));
      listeners[id] = obj;
      if (typeof name === 'object') callback = this;
      obj[implementation](name, callback, this);
      return this;
    };
  });

  // Aliases for backwards compatibility.
  Events.bind   = Events.on;
  Events.unbind = Events.off;

  // Mixin utility
  Events.mixin = function(proto) {
    var exports = ['on', 'once', 'off', 'trigger', 'stopListening', 'listenTo',
                   'listenToOnce', 'bind', 'unbind'];
    _.each(exports, function(name) {
      proto[name] = this[name];
    }, this);
    return proto;
  };

  // Export Events as BackboneEvents depending on current context
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = Events;
    }
    exports.BackboneEvents = Events;
  }else if (typeof define === "function"  && typeof define.amd == "object") {
    define(function() {
      return Events;
    });
  } else {
    root.BackboneEvents = Events;
  }
})(this);

},{}],4:[function(require,module,exports){
module.exports = require('./backbone-events-standalone');

},{"./backbone-events-standalone":3}],5:[function(require,module,exports){
var events = require("backbone-events-standalone");

events.onAll = function(callback,context){
  this.on("all", callback,context);
  return this;
};

// Mixin utility
events.oldMixin = events.mixin;
events.mixin = function(proto) {
  events.oldMixin(proto);
  // add custom onAll
  var exports = ['onAll'];
  for(var i=0; i < exports.length;i++){
    var name = exports[i];
    proto[name] = this[name];
  }
  return proto;
};

module.exports = events;

},{"backbone-events-standalone":4}],6:[function(require,module,exports){
module.exports.model = require("./model");

module.exports.stage = require("./stage");



},{"./model":7,"./stage":8}],7:[function(require,module,exports){
var Feature;

module.exports = Feature = (function() {
  Feature.prototype.xStart = -1;

  Feature.prototype.xEnd = -1;

  Feature.prototype.height = -1;

  Feature.prototype.text = "";

  Feature.prototype.fillColor = "red";

  Feature.prototype.fillOpacity = 0.5;

  Feature.prototype.type = "rectangle";

  Feature.prototype.borderSize = 1;

  Feature.prototype.borderColor = "black";

  Feature.prototype.borderOpacity = 0.5;

  function Feature(xStart, xEnd, text, fillColor) {
    this.xStart = xStart;
    this.xEnd = xEnd;
    this.text = text;
    this.fillColor = fillColor;
  }

  return Feature;

})();



},{}],8:[function(require,module,exports){
var Eventhandler, FeatureElement, Utils;

Utils = require("./utils");

Eventhandler = require("biojs-events");

module.exports = FeatureElement = (function() {
  function FeatureElement(divName, features, featureWidth, fontSize, maxLen, leftOffset) {
    var el, featureSpan;
    Eventhandler.mixin(FeatureElement.prototype);
    if (typeof divName === "string") {
      featureSpan = document.getElementById(divName);
    } else {
      featureSpan = divName;
    }
    if (featureWidth == null) {
      featureWidth = 10;
    }
    if (fontSize == null) {
      fontSize = 18;
    }
    if (maxLen == null) {
      maxLen = void 0;
    }
    if (leftOffset == null) {
      leftOffset = 0;
    }
    el = this.create(featureSpan, features, featureWidth, fontSize, maxLen, leftOffset);
  }

  FeatureElement.prototype.create = function(featureSpan, features, featureWidth, fontSize, maxLen, leftOffset) {
    var feature, i, j, k, labelOffset, len, len1, len2, rect, ref, residueGroup, row, rowLength, rowSpan, rows, rowsNeeded, x;
    if ((features != null) && (features != null ? features.length : void 0) > 0) {
      if (maxLen == null) {
        maxLen = features.reduce(function(a, b) {
          return Math.max(a, b.end, 0);
        });
      }
      features = FeatureElement.sortFeatureArray(features);
      rowsNeeded = FeatureElement.getMinRows(features, maxLen);
      rows = (function() {
        var i, ref, results;
        results = [];
        for (x = i = 1, ref = rowsNeeded; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
          results.push(document.createDocumentFragment());
        }
        return results;
      })();
      for (i = 0, len = features.length; i < len; i++) {
        feature = features[i];
        rect = this.drawRectangle(feature, featureWidth, fontSize);
        for (j = 0, len1 = rows.length; j < len1; j++) {
          row = rows[j];
          rowLength = row.childNodes.length;
          if (rowLength === 0 || ((ref = row.childNodes[rowLength - 1]) != null ? ref.xEnd : void 0) < feature.xStart) {
            if (rowLength > 0) {
              rect.style.marginLeft = (featureWidth * (feature.xStart - 1 - row.childNodes[rowLength - 1].xEnd)) + "px";
            } else if (rowLength === 0) {
              rect.style.marginLeft = (featureWidth * feature.xStart) + "px";
            }
            row.appendChild(rect);
            break;
          }
        }
      }
      residueGroup = document.createDocumentFragment();
      for (k = 0, len2 = rows.length; k < len2; k++) {
        row = rows[k];
        rowSpan = document.createElement("span");
        rowSpan.className = "biojs-easy-feature-row";
        rowSpan.style.display = "block";
        if (leftOffset != null) {
          labelOffset = document.createElement("span");
          labelOffset.style.width = leftOffset + "px";
          rowSpan.appendChild(labelOffset);
        }
        rowSpan.appendChild(row);
        residueGroup.appendChild(rowSpan);
      }
      featureSpan.className = "biojs-easy-feature";
      featureSpan.style.display = "block";
      featureSpan.appendChild(residueGroup);
    }
    return featureSpan;
  };

  FeatureElement.prototype.drawRectangle = function(feature, width, fontSize) {
    var bgColor, borderColor, ref, residueSpan;
    residueSpan = document.createElement("span");
    if (((ref = feature.text) != null ? ref.length : void 0) > 0) {
      residueSpan.textContent = feature.text;
    } else {
      residueSpan.textContent = "#";
    }
    bgColor = Utils.hex2rgb(feature.fillColor);
    residueSpan.style.backgroundColor = Utils.rgba(bgColor, feature.fillOpacity);
    residueSpan.bgColor = bgColor;
    borderColor = feature.borderColor;
    residueSpan.style.border = feature.borderSize + "px solid " + borderColor;
    residueSpan.style.width = (width * (feature.xEnd - feature.xStart + 1)) + "px";
    residueSpan.style.fontSize = fontSize + "px";
    residueSpan.xEnd = feature.xEnd;
    residueSpan.style.display = "inline-block";
    residueSpan.addEventListener("mouseover", (function(_this) {
      return function(event) {
        var div, opacity;
        opacity = 0.8;
        div = event.target;
        div.style.backgroundColor = Utils.rgba(div.bgColor, opacity);
        return _this.trigger("mouseover", feature);
      };
    })(this));
    residueSpan.addEventListener("mouseout", (function(_this) {
      return function() {
        var div, opacity;
        opacity = 0.5;
        div = event.target;
        div.style.backgroundColor = Utils.rgba(div.bgColor, opacity);
        return _this.trigger("mouseover", feature);
      };
    })(this));
    residueSpan.addEventListener("click", (function(_this) {
      return function() {
        return _this.trigger("click", feature);
      };
    })(this));
    return residueSpan;
  };

  FeatureElement.sortFeatureArray = function(arr) {
    var compare;
    compare = function(a, b) {
      if (a.xStart < b.xStart) {
        return -1;
      } else if (a.xStart > b.xStart) {
        return 1;
      }
    };
    return arr.sort(compare);
  };

  FeatureElement.getMinRows = function(features, seqLen) {
    var feature, i, j, k, len, max, ref, ref1, ref2, rows, x;
    rows = (function() {
      var i, ref, results;
      results = [];
      for (x = i = 1, ref = seqLen; 1 <= ref ? i <= ref : i >= ref; x = 1 <= ref ? ++i : --i) {
        results.push(0);
      }
      return results;
    })();
    for (i = 0, len = features.length; i < len; i++) {
      feature = features[i];
      for (x = j = ref = feature.xStart, ref1 = feature.xEnd; j <= ref1; x = j += 1) {
        rows[x]++;
      }
    }
    max = 0;
    for (x = k = 0, ref2 = seqLen - 1; k <= ref2; x = k += 1) {
      if (rows[x] > max) {
        max = rows[x];
      }
    }
    return max;
  };

  return FeatureElement;

})();



},{"./utils":9,"biojs-events":5}],9:[function(require,module,exports){
var Utils;

Utils = {};

Utils.rgb = function(r, g, b) {
  if (typeof g === "undefined") {
    return Utils.rgb(r.r, r.g, r.b);
  }
  return ["rgb(", [r || 0, g || 0, b || 0].join(","), ")"].join();
};

Utils.rgba = function(r, g, b, a) {
  if (typeof b === "undefined") {
    return Utils.rgba(r.r, r.g, r.b, g);
  }
  return ["rgba(", [r || 0, g || 0, b || 0, a || 1].join(","), ")"].join("");
};

Utils.hex2rgb = function(hex) {
  var b, bigint, g, r, strHex;
  strHex = Utils.string2hex(hex);
  if (strHex != null) {
    hex = strHex;
  }
  bigint = parseInt(hex, 16);
  if (!isNaN(bigint)) {
    r = (bigint >> 16) & 255;
    g = (bigint >> 8) & 255;
    b = bigint & 255;
    return {
      r: r,
      g: g,
      b: b
    };
  }
};

Utils.string2hex = function(string2hex) {
  var colours;
  colours = {
    "aliceblue": "f0f8ff",
    "antiquewhite": "faebd7",
    "aqua": "00ffff",
    "aquamarine": "7fffd4",
    "azure": "f0ffff",
    "beige": "f5f5dc",
    "bisque": "ffe4c4",
    "black": "000000",
    "blanchedalmond": "ffebcd",
    "blue": "0000ff",
    "blueviolet": "8a2be2",
    "brown": "a52a2a",
    "burlywood": "deb887",
    "cadetblue": "5f9ea0",
    "chartreuse": "7fff00",
    "chocolate": "d2691e",
    "coral": "ff7f50",
    "cornflowerblue": "6495ed",
    "cornsilk": "fff8dc",
    "crimson": "dc143c",
    "cyan": "00ffff",
    "darkblue": "00008b",
    "darkcyan": "008b8b",
    "darkgoldenrod": "b8860b",
    "darkgray": "a9a9a9",
    "darkgreen": "006400",
    "darkkhaki": "bdb76b",
    "darkmagenta": "8b008b",
    "darkolivegreen": "556b2f",
    "darkorange": "ff8c00",
    "darkorchid": "9932cc",
    "darkred": "8b0000",
    "darksalmon": "e9967a",
    "darkseagreen": "8fbc8f",
    "darkslateblue": "483d8b",
    "darkslategray": "2f4f4f",
    "darkturquoise": "00ced1",
    "darkviolet": "9400d3",
    "deeppink": "ff1493",
    "deepskyblue": "00bfff",
    "dimgray": "696969",
    "dodgerblue": "1e90ff",
    "firebrick": "b22222",
    "floralwhite": "fffaf0",
    "forestgreen": "228b22",
    "fuchsia": "ff00ff",
    "gainsboro": "dcdcdc",
    "ghostwhite": "f8f8ff",
    "gold": "ffd700",
    "goldenrod": "daa520",
    "gray": "808080",
    "green": "008000",
    "greenyellow": "adff2f",
    "honeydew": "f0fff0",
    "hotpink": "ff69b4",
    "indianred ": "cd5c5c",
    "indigo": "4b0082",
    "ivory": "fffff0",
    "khaki": "f0e68c",
    "lavender": "e6e6fa",
    "lavenderblush": "fff0f5",
    "lawngreen": "7cfc00",
    "lemonchiffon": "fffacd",
    "lightblue": "add8e6",
    "lightcoral": "f08080",
    "lightcyan": "e0ffff",
    "lightgoldenrodyellow": "fafad2",
    "lightgrey": "d3d3d3",
    "lightgreen": "90ee90",
    "lightpink": "ffb6c1",
    "lightsalmon": "ffa07a",
    "lightseagreen": "20b2aa",
    "lightskyblue": "87cefa",
    "lightslategray": "778899",
    "lightsteelblue": "b0c4de",
    "lightyellow": "ffffe0",
    "lime": "00ff00",
    "limegreen": "32cd32",
    "linen": "faf0e6",
    "magenta": "ff00ff",
    "maroon": "800000",
    "mediumaquamarine": "66cdaa",
    "mediumblue": "0000cd",
    "mediumorchid": "ba55d3",
    "mediumpurple": "9370d8",
    "mediumseagreen": "3cb371",
    "mediumslateblue": "7b68ee",
    "mediumspringgreen": "00fa9a",
    "mediumturquoise": "48d1cc",
    "mediumvioletred": "c71585",
    "midnightblue": "191970",
    "mintcream": "f5fffa",
    "mistyrose": "ffe4e1",
    "moccasin": "ffe4b5",
    "navajowhite": "ffdead",
    "navy": "000080",
    "oldlace": "fdf5e6",
    "olive": "808000",
    "olivedrab": "6b8e23",
    "orange": "ffa500",
    "orangered": "ff4500",
    "orchid": "da70d6",
    "palegoldenrod": "eee8aa",
    "palegreen": "98fb98",
    "paleturquoise": "afeeee",
    "palevioletred": "d87093",
    "papayawhip": "ffefd5",
    "peachpuff": "ffdab9",
    "peru": "cd853f",
    "pink": "ffc0cb",
    "plum": "dda0dd",
    "powderblue": "b0e0e6",
    "purple": "800080",
    "red": "ff0000",
    "rosybrown": "bc8f8f",
    "royalblue": "4169e1",
    "saddlebrown": "8b4513",
    "salmon": "fa8072",
    "sandybrown": "f4a460",
    "seagreen": "2e8b57",
    "seashell": "fff5ee",
    "sienna": "a0522d",
    "silver": "c0c0c0",
    "skyblue": "87ceeb",
    "slateblue": "6a5acd",
    "slategray": "708090",
    "snow": "fffafa",
    "springgreen": "00ff7f",
    "steelblue": "4682b4",
    "tan": "d2b48c",
    "teal": "008080",
    "thistle": "d8bfd8",
    "tomato": "ff6347",
    "turquoise": "40e0d0",
    "violet": "ee82ee",
    "wheat": "f5deb3",
    "white": "ffffff",
    "whitesmoke": "f5f5f5",
    "yellow": "ffff00",
    "yellowgreen": "9acd32"
  };
  if (colours[string2hex.toLowerCase()] != null) {
    return colours[string2hex.toLowerCase()];
  }
  return void 0;
};

Utils.rgb2hex = function(rgb) {
  rgb = rgb.match(/^rgb\((\d+),\s*(\d+),\s*(\d+)\)$/);
  return "#" + ("0" + parseInt(rgb[1], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[2], 10).toString(16)).slice(-2) + ("0" + parseInt(rgb[3], 10).toString(16)).slice(-2);
};

module.exports = Utils;



},{}]},{},[1])